// THIS CODE WAS GENERATED BY A VERY EXHAUSTED DEVELOPER
// DO NOT EDIT !

package cpu

import (
	"github.com/damilolarandolph/casper/bits"
)

type shiftType uint8

const (
	lsl = shiftType(iota)
	lsr
	asr
	ror
	rrx
)

func lli(cpu *CPU) (uint32, bool) {
	instruction := cpu.currentInstruction
	shiftAmount := int(bits.GetBits(instruction, 11, 7)) & 0xff
	// Register to be shifted
	shiftReg := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(shiftReg)
	carryOut := logicalShiftLeft(&operand, shiftAmount, cpu.isFlag(carry))

	return operand, carryOut
}

func llr(cpu *CPU) (uint32, bool) {
	instruction := cpu.currentInstruction
	// Reg holding the amount of the shift
	shiftAmountReg := reg(bits.GetBits(instruction, 11, 8))
	shiftAmount := int(cpu.readReg(shiftAmountReg)) & 0xff

	shiftReg := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(shiftReg)
	carryOut := logicalShiftLeft(&operand, shiftAmount, cpu.isFlag(carry))

	return operand, carryOut
}

func lri(cpu *CPU) (uint32, bool) {
	instruction := cpu.currentInstruction
	shiftAmount := int(bits.GetBits(instruction, 11, 7)) & 0xff
	if shiftAmount == 0 {
		shiftAmount = 32
	}
	register := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(register)

	carryOut := logicalShiftRight(&operand, shiftAmount, cpu.isFlag(carry))
	return operand, carryOut
}

func lrr(cpu *CPU) (uint32, bool) {
	instruction := cpu.currentInstruction
	register := reg(bits.GetBits(instruction, 11, 8))
	shiftAmount := int(cpu.readReg(register)) & 0xff

	rm := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(rm)
	carryOut := logicalShiftRight(&operand, shiftAmount, cpu.isFlag(carry))
	return operand, carryOut
}

func ari(cpu *CPU) (uint32, bool) {
	instruction := cpu.currentInstruction
	shiftAmount := int(bits.GetBits(instruction, 11, 7)) & 0xff
	if shiftAmount == 0 {
		shiftAmount = 32
	}
	register := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(register)

	carryOut := arthShiftRight(&operand, shiftAmount, cpu.isFlag(carry))
	return operand, carryOut
}

func arr(cpu *CPU) (uint32, bool) {
	instruction := cpu.currentInstruction
	register := reg(bits.GetBits(instruction, 11, 8))
	shiftAmount := int(cpu.readReg(register)) & 0xff

	rm := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(rm)
	carryOut := arthShiftRight(&operand, shiftAmount, cpu.isFlag(carry))
	return operand, carryOut
}

func rri(cpu *CPU) (uint32, bool) {

	instruction := cpu.currentInstruction
	shiftAmount := int(bits.GetBits(instruction, 11, 7)) & 0xff

	register := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(register)
	if shiftAmount == 0 {
		carryOut := rotateRightExtend(&operand, cpu.isFlag(carry))
		return operand, carryOut
	}
	carryOut := arthShiftRight(&operand, shiftAmount, cpu.isFlag(carry))
	return operand, carryOut
}

func rrr(cpu *CPU) (uint32, bool) {
	instruction := cpu.currentInstruction
	register := reg(bits.GetBits(instruction, 11, 8))
	shiftAmount := int(cpu.readReg(register)) & 0xff

	rm := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(rm)
	carryOut := rotateRight(&operand, shiftAmount, cpu.isFlag(carry))
	return operand, carryOut
}

func imm(cpu *CPU) (uint32, bool) {
	instruction := cpu.currentInstruction
	operand := bits.GetBits(instruction, 7, 0)
	rotate := int(bits.GetBits(instruction, 11, 8))
	carryOut := rotateRight(&operand, rotate*2, cpu.isFlag(carry))
	return operand, carryOut

}

type arthAddrMode func(cpu *CPU) (uint32, bool)

func isNegative(val uint32) bool {
	return bits.GetBit(val, 31)
}

func didOverflow(val1 uint32, val2 uint32) bool {
	return val2 > (0xffffffff - val1)
}

func didUnderflow(val1 uint32, val2 uint32) bool {
	return val2 > val1
}

func didSignOverflow(val1 uint32, val2 uint32) bool {
	signedVal1 := int32(val1)
	signedVal2 := int32(val2)
	result := int32(val1) + int32(val2)

	if signedVal1 < 0 && signedVal2 < 0 {
		return result >= 0
	} else if signedVal1 > 0 && signedVal2 > 0 {
		return result <= 0
	}

	return false

}

func parseDataInstr(instruction uint32) (reg, reg, bool) {
	setConditions := bits.GetBit(instruction, 20)

	destinationReg := reg(bits.GetBits(instruction, 15, 12))

	firstOpReg := reg(bits.GetBits(instruction, 19, 16))

	return firstOpReg, destinationReg, setConditions
}

// ADD Instructions

func add(addressingMode arthAddrMode, cpu *CPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destinationReg, setConditions := parseDataInstr(cpu.currentInstruction)
	secondOp, _ := addressingMode(cpu)
	firstOp := cpu.readReg(firstOpReg)
	result := firstOp + secondOp
	cpu.setReg(destinationReg, result)

	if !setConditions {
		return
	}

	if destinationReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(carry, didOverflow(firstOp, secondOp))
	cpu.setFlag(overflow, didSignOverflow(firstOp, secondOp))
	cpu.setFlag(zero, result == 0)
}

func addC(addressingMode arthAddrMode, cpu *CPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destinationReg, setConditions := parseDataInstr(cpu.currentInstruction)
	secondOp, _ := addressingMode(cpu)
	firstOp := cpu.readReg(firstOpReg)
	if cpu.isFlag(carry) {
		secondOp++
	}
	result := firstOp + secondOp
	cpu.setReg(destinationReg, result)

	if !setConditions {
		return
	}

	if destinationReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(carry, didOverflow(firstOp, secondOp))
	cpu.setFlag(overflow, didSignOverflow(firstOp, secondOp))
	cpu.setFlag(zero, result == 0)
}

// Add Instruction handlers
var addLLI = func(cpu *CPU) {
	add(lli, cpu)
}

var addLLR = func(cpu *CPU) {
	add(llr, cpu)
}

var addLRI = func(cpu *CPU) {
	add(lri, cpu)
}

var addLRR = func(cpu *CPU) {
	add(lrr, cpu)
}

var addARI = func(cpu *CPU) {
	add(ari, cpu)
}

var addARR = func(cpu *CPU) {
	add(arr, cpu)
}

var addRRI = func(cpu *CPU) {
	add(rri, cpu)
}

var addRRR = func(cpu *CPU) {
	add(rrr, cpu)
}

var addIMM = func(cpu *CPU) {
	add(imm, cpu)
}

// ADDC instruction handlers
var addCarryLLI = func(cpu *CPU) {
	addC(lli, cpu)
}

var addCarryLLR = func(cpu *CPU) {
	addC(llr, cpu)
}

var addCarryLRI = func(cpu *CPU) {
	addC(lri, cpu)
}

var addCarryLRR = func(cpu *CPU) {
	addC(lrr, cpu)
}

var addCarryARI = func(cpu *CPU) {
	addC(ari, cpu)
}

var addCarryARR = func(cpu *CPU) {
	addC(arr, cpu)
}

var addCarryRRI = func(cpu *CPU) {
	addC(rri, cpu)
}

var addCarryRRR = func(cpu *CPU) {
	addC(rrr, cpu)
}

var addCarryIMM = func(cpu *CPU) {
	addC(imm, cpu)
}

// AND Instructions
func and(addressingMode arthAddrMode, cpu *CPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, carryOut := addressingMode(cpu)
	result := firstOp & secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}
	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}
	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)
}

var andLLI = func(cpu *CPU) {
	and(lli, cpu)
}

var andLLR = func(cpu *CPU) {
	and(llr, cpu)
}

var andLRI = func(cpu *CPU) {
	and(lri, cpu)
}

var andLRR = func(cpu *CPU) {
	and(lrr, cpu)
}

var andARI = func(cpu *CPU) {
	and(ari, cpu)
}

var andARR = func(cpu *CPU) {
	and(arr, cpu)
}

var andRRI = func(cpu *CPU) {
	and(rri, cpu)
}

var andRRR = func(cpu *CPU) {
	and(rrr, cpu)
}

var andIMM = func(cpu *CPU) {
	and(imm, cpu)
}

// BIC Instruction

func bic(addressingMode arthAddrMode, cpu *CPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, carryOut := addressingMode(cpu)
	result := firstOp & ^secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

var bicLLI = func(cpu *CPU) {
	bic(lli, cpu)
}

var bicLLR = func(cpu *CPU) {
	bic(llr, cpu)
}

var bicLRI = func(cpu *CPU) {
	bic(lri, cpu)
}

var bicLRR = func(cpu *CPU) {
	bic(lrr, cpu)
}

var bicARI = func(cpu *CPU) {
	bic(ari, cpu)
}

var bicARR = func(cpu *CPU) {
	bic(arr, cpu)
}

var bicRRI = func(cpu *CPU) {
	bic(rri, cpu)
}

var bicRRR = func(cpu *CPU) {
	bic(rrr, cpu)
}

var bicIMM = func(cpu *CPU) {
	bic(imm, cpu)
}

// Compare Negative (CMN)

func cmn(addressingMode arthAddrMode, cpu *CPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, _, _ := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, _ := addressingMode(cpu)
	result := firstOp + secondOp

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, didOverflow(firstOp, secondOp))
	cpu.setFlag(overflow, didSignOverflow(firstOp, secondOp))

}

var cmnLLI = func(cpu *CPU) {
	cmn(lli, cpu)
}

var cmnLLR = func(cpu *CPU) {
	cmn(llr, cpu)
}

var cmnLRI = func(cpu *CPU) {
	cmn(lri, cpu)
}

var cmnLRR = func(cpu *CPU) {
	cmn(lrr, cpu)
}

var cmnARI = func(cpu *CPU) {
	cmn(ari, cpu)
}

var cmnARR = func(cpu *CPU) {
	cmn(arr, cpu)
}

var cmnRRI = func(cpu *CPU) {
	cmn(rri, cpu)
}

var cmnRRR = func(cpu *CPU) {
	cmn(rrr, cpu)
}

var cmnIMM = func(cpu *CPU) {
	cmn(imm, cpu)
}

// Compare (CMP)

func cmp(addressingMode arthAddrMode, cpu *CPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, _, _ := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, _ := addressingMode(cpu)
	result := firstOp - secondOp

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, !didUnderflow(firstOp, secondOp))
	cpu.setFlag(overflow, didSignOverflow(firstOp, ^secondOp))
}

var cmpLLI = func(cpu *CPU) {
	cmp(lli, cpu)
}

var cmpLLR = func(cpu *CPU) {
	cmp(llr, cpu)
}

var cmpLRI = func(cpu *CPU) {
	cmp(lri, cpu)
}

var cmpLRR = func(cpu *CPU) {
	cmp(lrr, cpu)
}

var cmpARI = func(cpu *CPU) {
	cmp(ari, cpu)
}

var cmpARR = func(cpu *CPU) {
	cmp(arr, cpu)
}

var cmpRRI = func(cpu *CPU) {
	cmp(rri, cpu)
}

var cmpRRR = func(cpu *CPU) {
	cmp(rrr, cpu)
}

var cmpIMM = func(cpu *CPU) {
	cmp(imm, cpu)
}

// Exclusive Or (EOR)
func eor(addressingMode arthAddrMode, cpu *CPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, carryOut := addressingMode(cpu)
	result := firstOp ^ secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

var eorLLI = func(cpu *CPU) {
	eor(lli, cpu)
}

var eorLLR = func(cpu *CPU) {
	eor(llr, cpu)
}

var eorLRI = func(cpu *CPU) {
	eor(lri, cpu)
}

var eorLRR = func(cpu *CPU) {
	eor(lrr, cpu)
}

var eorARI = func(cpu *CPU) {
	eor(ari, cpu)
}

var eorARR = func(cpu *CPU) {
	eor(arr, cpu)
}

var eorRRI = func(cpu *CPU) {
	eor(rri, cpu)
}

var eorRRR = func(cpu *CPU) {
	eor(rrr, cpu)
}

var eorIMM = func(cpu *CPU) {
	eor(imm, cpu)
}

// Move (MOV)
func mov(addressingMode arthAddrMode, cpu *CPU) {
	if !testCondition(cpu) {
		return
	}
	_, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	secondOp, carryOut := addressingMode(cpu)
	result := secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

var movLLI = func(cpu *CPU) {
	mov(lli, cpu)
}

var movLLR = func(cpu *CPU) {
	mov(llr, cpu)
}

var movLRI = func(cpu *CPU) {
	mov(lri, cpu)
}

var movLRR = func(cpu *CPU) {
	mov(lrr, cpu)
}

var movARI = func(cpu *CPU) {
	mov(ari, cpu)
}

var movARR = func(cpu *CPU) {
	mov(arr, cpu)
}

var movRRI = func(cpu *CPU) {
	mov(rri, cpu)
}

var movRRR = func(cpu *CPU) {
	mov(rrr, cpu)
}

var movIMM = func(cpu *CPU) {
	mov(imm, cpu)
}

// Move Negative (MVN)
func mvn(addressingMode arthAddrMode, cpu *CPU) {
	if !testCondition(cpu) {
		return
	}
	_, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	secondOp, carryOut := addressingMode(cpu)
	result := ^secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

var mvnLLI = func(cpu *CPU) {
	mvn(lli, cpu)
}

var mvnLLR = func(cpu *CPU) {
	mvn(llr, cpu)
}

var mvnLRI = func(cpu *CPU) {
	mvn(lri, cpu)
}

var mvnLRR = func(cpu *CPU) {
	mvn(lrr, cpu)
}

var mvnARI = func(cpu *CPU) {
	mvn(ari, cpu)
}

var mvnARR = func(cpu *CPU) {
	mvn(arr, cpu)
}

var mvnRRI = func(cpu *CPU) {
	mvn(rri, cpu)
}

var mvnRRR = func(cpu *CPU) {
	mvn(rrr, cpu)
}

var mvnIMM = func(cpu *CPU) {
	mvn(imm, cpu)
}

// Logical OR (ORR)
func orr(addressingMode arthAddrMode, cpu *CPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, carryOut := addressingMode(cpu)
	result := firstOp | secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

var orrLLI = func(cpu *CPU) {
	orr(lli, cpu)
}

var orrLLR = func(cpu *CPU) {
	orr(llr, cpu)
}

var orrLRI = func(cpu *CPU) {
	orr(lri, cpu)
}

var orrLRR = func(cpu *CPU) {
	orr(lrr, cpu)
}

var orrARI = func(cpu *CPU) {
	orr(ari, cpu)
}

var orrARR = func(cpu *CPU) {
	orr(arr, cpu)
}

var orrRRI = func(cpu *CPU) {
	orr(rri, cpu)
}

var orrRRR = func(cpu *CPU) {
	orr(rrr, cpu)
}

var orrIMM = func(cpu *CPU) {
	orr(imm, cpu)
}

// Reverse Subtract (RSB)
func rsb(addressingMode arthAddrMode, cpu *CPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, _ := addressingMode(cpu)
	result := secondOp - firstOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, !didUnderflow(secondOp, firstOp))
	cpu.setFlag(overflow, didOverflow(secondOp, ^firstOp))

}

var rsbLLI = func(cpu *CPU) {
	rsb(lli, cpu)
}

var rsbLLR = func(cpu *CPU) {
	rsb(llr, cpu)
}

var rsbLRI = func(cpu *CPU) {
	rsb(lri, cpu)
}

var rsbLRR = func(cpu *CPU) {
	rsb(lrr, cpu)
}

var rsbARI = func(cpu *CPU) {
	rsb(ari, cpu)
}

var rsbARR = func(cpu *CPU) {
	rsb(arr, cpu)
}

var rsbRRI = func(cpu *CPU) {
	rsb(rri, cpu)
}

var rsbRRR = func(cpu *CPU) {
	rsb(rrr, cpu)
}

var rsbIMM = func(cpu *CPU) {
	rsb(imm, cpu)
}

// Reverse Subtract with Carry (RSC)
func rsc(addressingMode arthAddrMode, cpu *CPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	if !cpu.isFlag(carry) {
		firstOp++
	}
	secondOp, _ := addressingMode(cpu)
	result := secondOp - firstOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, !didUnderflow(secondOp, firstOp))
	cpu.setFlag(overflow, didOverflow(secondOp, ^firstOp))

}

var rscLLI = func(cpu *CPU) {
	rsc(lli, cpu)
}

var rscLLR = func(cpu *CPU) {
	rsc(llr, cpu)
}

var rscLRI = func(cpu *CPU) {
	rsc(lri, cpu)
}

var rscLRR = func(cpu *CPU) {
	rsc(lrr, cpu)
}

var rscARI = func(cpu *CPU) {
	rsc(ari, cpu)
}

var rscARR = func(cpu *CPU) {
	rsc(arr, cpu)
}

var rscRRI = func(cpu *CPU) {
	rsc(rri, cpu)
}

var rscRRR = func(cpu *CPU) {
	rsc(rrr, cpu)
}

var rscIMM = func(cpu *CPU) {
	rsc(imm, cpu)
}

// Subtract with Carry (SBC)
func sbc(addressingMode arthAddrMode, cpu *CPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, _ := addressingMode(cpu)
	if !cpu.isFlag(carry) {
		secondOp++
	}
	result := firstOp - secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, !didUnderflow(firstOp, secondOp))
	cpu.setFlag(overflow, didOverflow(firstOp, ^secondOp))

}

var sbcLLI = func(cpu *CPU) {
	sbc(lli, cpu)
}

var sbcLLR = func(cpu *CPU) {
	sbc(llr, cpu)
}

var sbcLRI = func(cpu *CPU) {
	sbc(lri, cpu)
}

var sbcLRR = func(cpu *CPU) {
	sbc(lrr, cpu)
}

var sbcARI = func(cpu *CPU) {
	sbc(ari, cpu)
}

var sbcARR = func(cpu *CPU) {
	sbc(arr, cpu)
}

var sbcRRI = func(cpu *CPU) {
	sbc(rri, cpu)
}

var sbcRRR = func(cpu *CPU) {
	sbc(rrr, cpu)
}

var sbcIMM = func(cpu *CPU) {
	sbc(imm, cpu)
}

// Subtract (SUB)
func sub(addressingMode arthAddrMode, cpu *CPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, _ := addressingMode(cpu)
	result := firstOp - secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, !didUnderflow(firstOp, secondOp))
	cpu.setFlag(overflow, didOverflow(firstOp, ^secondOp))

}

var subLLI = func(cpu *CPU) {
	sub(lli, cpu)
}

var subLLR = func(cpu *CPU) {
	sub(llr, cpu)
}

var subLRI = func(cpu *CPU) {
	sub(lri, cpu)
}

var subLRR = func(cpu *CPU) {
	sub(lrr, cpu)
}

var subARI = func(cpu *CPU) {
	sub(ari, cpu)
}

var subARR = func(cpu *CPU) {
	sub(arr, cpu)
}

var subRRI = func(cpu *CPU) {
	sub(rri, cpu)
}

var subRRR = func(cpu *CPU) {
	sub(rrr, cpu)
}

var subIMM = func(cpu *CPU) {
	sub(imm, cpu)
}

// Test Equivalence (TEQ)
func teq(addressingMode arthAddrMode, cpu *CPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, _ := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, carryOut := addressingMode(cpu)
	result := firstOp ^ secondOp
	cpu.setReg(destReg, result)

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

var teqLLI = func(cpu *CPU) {
	teq(lli, cpu)
}

var teqLLR = func(cpu *CPU) {
	teq(llr, cpu)
}

var teqLRI = func(cpu *CPU) {
	teq(lri, cpu)
}

var teqLRR = func(cpu *CPU) {
	teq(lrr, cpu)
}

var teqARI = func(cpu *CPU) {
	teq(ari, cpu)
}

var teqARR = func(cpu *CPU) {
	teq(arr, cpu)
}

var teqRRI = func(cpu *CPU) {
	teq(rri, cpu)
}

var teqRRR = func(cpu *CPU) {
	teq(rrr, cpu)
}

var teqIMM = func(cpu *CPU) {
	teq(imm, cpu)
}

// Test (TST)
func tst(addressingMode arthAddrMode, cpu *CPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, _ := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, carryOut := addressingMode(cpu)
	result := firstOp & secondOp
	cpu.setReg(destReg, result)

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

var tstLLI = func(cpu *CPU) {
	tst(lli, cpu)
}

var tstLLR = func(cpu *CPU) {
	tst(llr, cpu)
}

var tstLRI = func(cpu *CPU) {
	tst(lri, cpu)
}

var tstLRR = func(cpu *CPU) {
	tst(lrr, cpu)
}

var tstARI = func(cpu *CPU) {
	tst(ari, cpu)
}

var tstARR = func(cpu *CPU) {
	tst(arr, cpu)
}

var tstRRI = func(cpu *CPU) {
	tst(rri, cpu)
}

var tstRRR = func(cpu *CPU) {
	tst(rrr, cpu)
}

var tstIMM = func(cpu *CPU) {
	tst(imm, cpu)
}

func logicalShiftLeft(value *uint32, amount int, currentCarry bool) bool {

	if amount == 0 {
		return currentCarry
	}

	if amount < 32 {
		carryOut := bits.GetBit(*value, 32-amount)
		*value <<= amount
		return carryOut
	}

	if amount == 32 {
		carryOut := bits.GetBit(*value, 0)
		*value = 0
		return carryOut
	}

	*value = 0
	return false

}

func arthShiftRight(value *uint32, amount int, currentCarry bool) bool {
	if amount == 0 {
		return currentCarry
	}

	if amount < 32 {
		carryOut := bits.GetBit(*value, amount-1)
		bits.ShiftRightSigned(value, amount)
		return carryOut
	}

	if !bits.GetBit(*value, 31) {
		*value = 0
		return false
	}

	*value = 0xFFFFFFFF
	return true
}

func logicalShiftRight(value *uint32, amount int, currentCarry bool) bool {
	if amount == 0 {
		return currentCarry
	}

	if amount < 32 {
		carryOut := bits.GetBit(*value, amount-1)
		*value >>= amount
		return carryOut
	}

	if amount == 32 {
		carryOut := bits.GetBit(*value, 31)
		*value = 0
		return carryOut
	}

	*value = 0
	return false

}

func rotateRight(value *uint32, amount int, currentCarry bool) bool {
	if amount == 0 {
		return currentCarry
	}
	amount &= 0x1f
	if amount == 0 {
		return bits.GetBit(*value, 31)
	}

	carryOut := bits.GetBit(*value, amount-1)
	dup := *value
	dup <<= 31 - amount
	*value >>= amount
	*value |= dup
	return carryOut
}

func rotateRightExtend(value *uint32, currentCarry bool) bool {
	carryOut := bits.GetBit(*value, 0)
	*value >>= 1
	bits.SetBit(value, 31, currentCarry)
	return carryOut
}
