// THIS CODE WAS GENERATED BY A VERY EXHAUSTED DEVELOPER
// DO NOT EDIT !

package cpu

import (
	"github.com/damilolarandolph/casper/bits"
)

type shiftType uint8

const (
	lsl = shiftType(iota)
	lsr
	asr
	ror
	rrx
)

func (cpu *CPU) lli() (uint32, bool) {
	instruction := cpu.currentInstruction
	shiftAmount := int(bits.GetBits(instruction, 11, 7)) & 0xff
	// Register to be shifted
	shiftReg := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(shiftReg)
	carryOut := logicalShiftLeft(&operand, shiftAmount, cpu.isFlag(carry))

	return operand, carryOut
}

func (cpu *CPU) llr() (uint32, bool) {
	instruction := cpu.currentInstruction
	// Reg holding the amount of the shift
	shiftAmountReg := reg(bits.GetBits(instruction, 11, 8))
	shiftAmount := int(cpu.readReg(shiftAmountReg)) & 0xff

	shiftReg := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(shiftReg)
	carryOut := logicalShiftLeft(&operand, shiftAmount, cpu.isFlag(carry))

	return operand, carryOut
}

func (cpu *CPU) lri() (uint32, bool) {
	instruction := cpu.currentInstruction
	shiftAmount := int(bits.GetBits(instruction, 11, 7)) & 0xff
	if shiftAmount == 0 {
		shiftAmount = 32
	}
	register := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(register)

	carryOut := logicalShiftRight(&operand, shiftAmount, cpu.isFlag(carry))
	return operand, carryOut
}

func (cpu *CPU) lrr() (uint32, bool) {
	instruction := cpu.currentInstruction
	register := reg(bits.GetBits(instruction, 11, 8))
	shiftAmount := int(cpu.readReg(register)) & 0xff

	rm := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(rm)
	carryOut := logicalShiftRight(&operand, shiftAmount, cpu.isFlag(carry))
	return operand, carryOut
}

func (cpu *CPU) ari() (uint32, bool) {
	instruction := cpu.currentInstruction
	shiftAmount := int(bits.GetBits(instruction, 11, 7)) & 0xff
	if shiftAmount == 0 {
		shiftAmount = 32
	}
	register := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(register)

	carryOut := arthShiftRight(&operand, shiftAmount, cpu.isFlag(carry))
	return operand, carryOut
}

func (cpu *CPU) arr() (uint32, bool) {
	instruction := cpu.currentInstruction
	register := reg(bits.GetBits(instruction, 11, 8))
	shiftAmount := int(cpu.readReg(register)) & 0xff

	rm := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(rm)
	carryOut := arthShiftRight(&operand, shiftAmount, cpu.isFlag(carry))
	return operand, carryOut
}

func (cpu *CPU) rri() (uint32, bool) {

	instruction := cpu.currentInstruction
	shiftAmount := int(bits.GetBits(instruction, 11, 7)) & 0xff

	register := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(register)
	if shiftAmount == 0 {
		carryOut := rotateRightExtend(&operand, cpu.isFlag(carry))
		return operand, carryOut
	}
	carryOut := arthShiftRight(&operand, shiftAmount, cpu.isFlag(carry))
	return operand, carryOut
}

func (cpu *CPU) rrr() (uint32, bool) {
	instruction := cpu.currentInstruction
	register := reg(bits.GetBits(instruction, 11, 8))
	shiftAmount := int(cpu.readReg(register)) & 0xff

	rm := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(rm)
	carryOut := rotateRight(&operand, shiftAmount, cpu.isFlag(carry))
	return operand, carryOut
}

func (cpu *CPU) imm() (uint32, bool) {
	instruction := cpu.currentInstruction
	operand := bits.GetBits(instruction, 7, 0)
	rotate := int(bits.GetBits(instruction, 11, 8))
	carryOut := rotateRight(&operand, rotate*2, cpu.isFlag(carry))
	return operand, carryOut

}

type arthAddrMode func() (uint32, bool)

func isNegative(val uint32) bool {
	return bits.GetBit(val, 31)
}

func didOverflow(val1 uint32, val2 uint32) bool {
	return val2 > (0xffffffff - val1)
}

func didUnderflow(val1 uint32, val2 uint32) bool {
	return val2 > val1
}

func didSignOverflow(val1 uint32, val2 uint32) bool {
	signedVal1 := int32(val1)
	signedVal2 := int32(val2)
	result := int32(val1) + int32(val2)

	if signedVal1 < 0 && signedVal2 < 0 {
		return result >= 0
	} else if signedVal1 > 0 && signedVal2 > 0 {
		return result <= 0
	}

	return false

}

func parseDataInstr(instruction uint32) (reg, reg, bool) {
	setConditions := bits.GetBit(instruction, 20)

	destinationReg := reg(bits.GetBits(instruction, 15, 12))

	firstOpReg := reg(bits.GetBits(instruction, 19, 16))

	return firstOpReg, destinationReg, setConditions
}

// ADD Instructions

func (cpu *CPU) add(addressingMode arthAddrMode) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destinationReg, setConditions := parseDataInstr(cpu.currentInstruction)
	secondOp, _ := addressingMode()
	firstOp := cpu.readReg(firstOpReg)
	result := firstOp + secondOp
	cpu.setReg(destinationReg, result)

	if !setConditions {
		return
	}

	if destinationReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(carry, didOverflow(firstOp, secondOp))
	cpu.setFlag(overflow, didSignOverflow(firstOp, secondOp))
	cpu.setFlag(zero, result == 0)
}

func (cpu *CPU) addC(addressingMode arthAddrMode) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destinationReg, setConditions := parseDataInstr(cpu.currentInstruction)
	secondOp, _ := addressingMode()
	firstOp := cpu.readReg(firstOpReg)
	if cpu.isFlag(carry) {
		secondOp++
	}
	result := firstOp + secondOp
	cpu.setReg(destinationReg, result)

	if !setConditions {
		return
	}

	if destinationReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(carry, didOverflow(firstOp, secondOp))
	cpu.setFlag(overflow, didSignOverflow(firstOp, secondOp))
	cpu.setFlag(zero, result == 0)
}

// Add Instruction handlers
var addLLI = func(cpu *CPU) {
	cpu.add(cpu.lli)
}

var addLLR = func(cpu *CPU) {
	cpu.add(cpu.llr)
}

var addLRI = func(cpu *CPU) {
	cpu.add(cpu.lri)
}

var addLRR = func(cpu *CPU) {
	cpu.add(cpu.lrr)
}

var addARI = func(cpu *CPU) {
	cpu.add(cpu.ari)
}

var addARR = func(cpu *CPU) {
	cpu.add(cpu.arr)
}

var addRRI = func(cpu *CPU) {
	cpu.add(cpu.rri)
}

var addRRR = func(cpu *CPU) {
	cpu.add(cpu.rrr)
}

var addIMM = func(cpu *CPU) {
	cpu.add(cpu.imm)
}

// ADDC instruction handlers
var addCarryLLI = func(cpu *CPU) {
	cpu.addC(cpu.lli)
}

var addCarryLLR = func(cpu *CPU) {
	cpu.addC(cpu.llr)
}

var addCarryLRI = func(cpu *CPU) {
	cpu.addC(cpu.lri)
}

var addCarryLRR = func(cpu *CPU) {
	cpu.addC(cpu.lrr)
}

var addCarryARI = func(cpu *CPU) {
	cpu.addC(cpu.ari)
}

var addCarryARR = func(cpu *CPU) {
	cpu.addC(cpu.arr)
}

var addCarryRRI = func(cpu *CPU) {
	cpu.addC(cpu.rri)
}

var addCarryRRR = func(cpu *CPU) {
	cpu.addC(cpu.rrr)
}

var addCarryIMM = func(cpu *CPU) {
	cpu.addC(cpu.imm)
}

// AND Instructions
func (cpu *CPU) and(addressingMode arthAddrMode) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, carryOut := addressingMode()
	result := firstOp & secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}
	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}
	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)
}

var andLLI = func(cpu *CPU) {
	cpu.and(cpu.lli)
}

var andLLR = func(cpu *CPU) {
	cpu.and(cpu.llr)
}

var andLRI = func(cpu *CPU) {
	cpu.and(cpu.lri)
}

var andLRR = func(cpu *CPU) {
	cpu.and(cpu.lrr)
}

var andARI = func(cpu *CPU) {
	cpu.and(cpu.ari)
}

var andARR = func(cpu *CPU) {
	cpu.and(cpu.arr)
}

var andRRI = func(cpu *CPU) {
	cpu.and(cpu.rri)
}

var andRRR = func(cpu *CPU) {
	cpu.and(cpu.rrr)
}

var andIMM = func(cpu *CPU) {
	cpu.and(cpu.imm)
}

// BIC Instruction

func (cpu *CPU) bic(addressingMode arthAddrMode) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, carryOut := addressingMode()
	result := firstOp & ^secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

var bicLLI = func(cpu *CPU) {
	cpu.bic(cpu.lli)
}

var bicLLR = func(cpu *CPU) {
	cpu.bic(cpu.llr)
}

var bicLRI = func(cpu *CPU) {
	cpu.bic(cpu.lri)
}

var bicLRR = func(cpu *CPU) {
	cpu.bic(cpu.lrr)
}

var bicARI = func(cpu *CPU) {
	cpu.bic(cpu.ari)
}

var bicARR = func(cpu *CPU) {
	cpu.bic(cpu.arr)
}

var bicRRI = func(cpu *CPU) {
	cpu.bic(cpu.rri)
}

var bicRRR = func(cpu *CPU) {
	cpu.bic(cpu.rrr)
}

var bicIMM = func(cpu *CPU) {
	cpu.bic(cpu.imm)
}

// Compare Negative (CMN)

func (cpu *CPU) cmn(addressingMode arthAddrMode) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, _, _ := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, _ := addressingMode()
	result := firstOp + secondOp

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, didOverflow(firstOp, secondOp))
	cpu.setFlag(overflow, didSignOverflow(firstOp, secondOp))

}

var cmnLLI = func(cpu *CPU) {
	cpu.cmn(cpu.lli)
}

var cmnLLR = func(cpu *CPU) {
	cpu.cmn(cpu.llr)
}

var cmnLRI = func(cpu *CPU) {
	cpu.cmn(cpu.lri)
}

var cmnLRR = func(cpu *CPU) {
	cpu.cmn(cpu.lrr)
}

var cmnARI = func(cpu *CPU) {
	cpu.cmn(cpu.ari)
}

var cmnARR = func(cpu *CPU) {
	cpu.cmn(cpu.arr)
}

var cmnRRI = func(cpu *CPU) {
	cpu.cmn(cpu.rri)
}

var cmnRRR = func(cpu *CPU) {
	cpu.cmn(cpu.rrr)
}

var cmnIMM = func(cpu *CPU) {
	cpu.cmn(cpu.imm)
}

// Compare (CMP)

func (cpu *CPU) cmp(addressingMode arthAddrMode) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, _, _ := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, _ := addressingMode()
	result := firstOp - secondOp

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, !didUnderflow(firstOp, secondOp))
	cpu.setFlag(overflow, didSignOverflow(firstOp, ^secondOp))
}

var cmpLLI = func(cpu *CPU) {
	cpu.cmp(cpu.lli)
}

var cmpLLR = func(cpu *CPU) {
	cpu.cmp(cpu.llr)
}

var cmpLRI = func(cpu *CPU) {
	cpu.cmp(cpu.lri)
}

var cmpLRR = func(cpu *CPU) {
	cpu.cmp(cpu.lrr)
}

var cmpARI = func(cpu *CPU) {
	cpu.cmp(cpu.ari)
}

var cmpARR = func(cpu *CPU) {
	cpu.cmp(cpu.arr)
}

var cmpRRI = func(cpu *CPU) {
	cpu.cmp(cpu.rri)
}

var cmpRRR = func(cpu *CPU) {
	cpu.cmp(cpu.rrr)
}

var cmpIMM = func(cpu *CPU) {
	cpu.cmp(cpu.imm)
}

// Exclusive Or (EOR)
func (cpu *CPU) eor(addressingMode arthAddrMode) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, carryOut := addressingMode()
	result := firstOp ^ secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

var eorLLI = func(cpu *CPU) {
	cpu.eor(cpu.lli)
}

var eorLLR = func(cpu *CPU) {
	cpu.eor(cpu.llr)
}

var eorLRI = func(cpu *CPU) {
	cpu.eor(cpu.lri)
}

var eorLRR = func(cpu *CPU) {
	cpu.eor(cpu.lrr)
}

var eorARI = func(cpu *CPU) {
	cpu.eor(cpu.ari)
}

var eorARR = func(cpu *CPU) {
	cpu.eor(cpu.arr)
}

var eorRRI = func(cpu *CPU) {
	cpu.eor(cpu.rri)
}

var eorRRR = func(cpu *CPU) {
	cpu.eor(cpu.rrr)
}

var eorIMM = func(cpu *CPU) {
	cpu.eor(cpu.imm)
}

// Move (MOV)
func (cpu *CPU) mov(addressingMode arthAddrMode) {
	if !testCondition(cpu) {
		return
	}
	_, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	secondOp, carryOut := addressingMode()
	result := secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

var movLLI = func(cpu *CPU) {
	cpu.mov(cpu.lli)
}

var movLLR = func(cpu *CPU) {
	cpu.mov(cpu.llr)
}

var movLRI = func(cpu *CPU) {
	cpu.mov(cpu.lri)
}

var movLRR = func(cpu *CPU) {
	cpu.mov(cpu.lrr)
}

var movARI = func(cpu *CPU) {
	cpu.mov(cpu.ari)
}

var movARR = func(cpu *CPU) {
	cpu.mov(cpu.arr)
}

var movRRI = func(cpu *CPU) {
	cpu.mov(cpu.rri)
}

var movRRR = func(cpu *CPU) {
	cpu.mov(cpu.rrr)
}

var movIMM = func(cpu *CPU) {
	cpu.mov(cpu.imm)
}

// Move Negative (MVN)
func (cpu *CPU) mvn(addressingMode arthAddrMode) {
	if !testCondition(cpu) {
		return
	}
	_, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	secondOp, carryOut := addressingMode()
	result := ^secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

var mvnLLI = func(cpu *CPU) {
	cpu.mvn(cpu.lli)
}

var mvnLLR = func(cpu *CPU) {
	cpu.mvn(cpu.llr)
}

var mvnLRI = func(cpu *CPU) {
	cpu.mvn(cpu.lri)
}

var mvnLRR = func(cpu *CPU) {
	cpu.mvn(cpu.lrr)
}

var mvnARI = func(cpu *CPU) {
	cpu.mvn(cpu.ari)
}

var mvnARR = func(cpu *CPU) {
	cpu.mvn(cpu.arr)
}

var mvnRRI = func(cpu *CPU) {
	cpu.mvn(cpu.rri)
}

var mvnRRR = func(cpu *CPU) {
	cpu.mvn(cpu.rrr)
}

var mvnIMM = func(cpu *CPU) {
	cpu.mvn(cpu.imm)
}

// Logical OR (ORR)
func (cpu *CPU) orr(addressingMode arthAddrMode) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, carryOut := addressingMode()
	result := firstOp | secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

var orrLLI = func(cpu *CPU) {
	cpu.orr(cpu.lli)
}

var orrLLR = func(cpu *CPU) {
	cpu.orr(cpu.llr)
}

var orrLRI = func(cpu *CPU) {
	cpu.orr(cpu.lri)
}

var orrLRR = func(cpu *CPU) {
	cpu.orr(cpu.lrr)
}

var orrARI = func(cpu *CPU) {
	cpu.orr(cpu.ari)
}

var orrARR = func(cpu *CPU) {
	cpu.orr(cpu.arr)
}

var orrRRI = func(cpu *CPU) {
	cpu.orr(cpu.rri)
}

var orrRRR = func(cpu *CPU) {
	cpu.orr(cpu.rrr)
}

var orrIMM = func(cpu *CPU) {
	cpu.orr(cpu.imm)
}

// Reverse Subtract (RSB)
func (cpu *CPU) rsb(addressingMode arthAddrMode) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, _ := addressingMode()
	result := secondOp - firstOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, !didUnderflow(secondOp, firstOp))
	cpu.setFlag(overflow, didOverflow(secondOp, ^firstOp))

}

var rsbLLI = func(cpu *CPU) {
	cpu.rsb(cpu.lli)
}

var rsbLLR = func(cpu *CPU) {
	cpu.rsb(cpu.llr)
}

var rsbLRI = func(cpu *CPU) {
	cpu.rsb(cpu.lri)
}

var rsbLRR = func(cpu *CPU) {
	cpu.rsb(cpu.lrr)
}

var rsbARI = func(cpu *CPU) {
	cpu.rsb(cpu.ari)
}

var rsbARR = func(cpu *CPU) {
	cpu.rsb(cpu.arr)
}

var rsbRRI = func(cpu *CPU) {
	cpu.rsb(cpu.rri)
}

var rsbRRR = func(cpu *CPU) {
	cpu.rsb(cpu.rrr)
}

var rsbIMM = func(cpu *CPU) {
	cpu.rsb(cpu.imm)
}

// Reverse Subtract with Carry (RSC)
func (cpu *CPU) rsc(addressingMode arthAddrMode) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	if !cpu.isFlag(carry) {
		firstOp++
	}
	secondOp, _ := addressingMode()
	result := secondOp - firstOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, !didUnderflow(secondOp, firstOp))
	cpu.setFlag(overflow, didOverflow(secondOp, ^firstOp))

}

var rscLLI = func(cpu *CPU) {
	cpu.rsc(cpu.lli)
}

var rscLLR = func(cpu *CPU) {
	cpu.rsc(cpu.llr)
}

var rscLRI = func(cpu *CPU) {
	cpu.rsc(cpu.lri)
}

var rscLRR = func(cpu *CPU) {
	cpu.rsc(cpu.lrr)
}

var rscARI = func(cpu *CPU) {
	cpu.rsc(cpu.ari)
}

var rscARR = func(cpu *CPU) {
	cpu.rsc(cpu.arr)
}

var rscRRI = func(cpu *CPU) {
	cpu.rsc(cpu.rri)
}

var rscRRR = func(cpu *CPU) {
	cpu.rsc(cpu.rrr)
}

var rscIMM = func(cpu *CPU) {
	cpu.rsc(cpu.imm)
}

// Subtract with Carry (SBC)
func (cpu *CPU) sbc(addressingMode arthAddrMode) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, _ := addressingMode()
	if !cpu.isFlag(carry) {
		secondOp++
	}
	result := firstOp - secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, !didUnderflow(firstOp, secondOp))
	cpu.setFlag(overflow, didOverflow(firstOp, ^secondOp))

}

var sbcLLI = func(cpu *CPU) {
	cpu.sbc(cpu.lli)
}

var sbcLLR = func(cpu *CPU) {
	cpu.sbc(cpu.llr)
}

var sbcLRI = func(cpu *CPU) {
	cpu.sbc(cpu.lri)
}

var sbcLRR = func(cpu *CPU) {
	cpu.sbc(cpu.lrr)
}

var sbcARI = func(cpu *CPU) {
	cpu.sbc(cpu.ari)
}

var sbcARR = func(cpu *CPU) {
	cpu.sbc(cpu.arr)
}

var sbcRRI = func(cpu *CPU) {
	cpu.sbc(cpu.rri)
}

var sbcRRR = func(cpu *CPU) {
	cpu.sbc(cpu.rrr)
}

var sbcIMM = func(cpu *CPU) {
	cpu.sbc(cpu.imm)
}

// Subtract (SUB)
func (cpu *CPU) sub(addressingMode arthAddrMode) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, _ := addressingMode()
	result := firstOp - secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, !didUnderflow(firstOp, secondOp))
	cpu.setFlag(overflow, didOverflow(firstOp, ^secondOp))

}

var subLLI = func(cpu *CPU) {
	cpu.sub(cpu.lli)
}

var subLLR = func(cpu *CPU) {
	cpu.sub(cpu.llr)
}

var subLRI = func(cpu *CPU) {
	cpu.sub(cpu.lri)
}

var subLRR = func(cpu *CPU) {
	cpu.sub(cpu.lrr)
}

var subARI = func(cpu *CPU) {
	cpu.sub(cpu.ari)
}

var subARR = func(cpu *CPU) {
	cpu.sub(cpu.arr)
}

var subRRI = func(cpu *CPU) {
	cpu.sub(cpu.rri)
}

var subRRR = func(cpu *CPU) {
	cpu.sub(cpu.rrr)
}

var subIMM = func(cpu *CPU) {
	cpu.sub(cpu.imm)
}

// Test Equivalence (TEQ)
func (cpu *CPU) teq(addressingMode arthAddrMode) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, _ := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, carryOut := addressingMode()
	result := firstOp ^ secondOp
	cpu.setReg(destReg, result)

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

var teqLLI = func(cpu *CPU) {
	cpu.teq(cpu.lli)
}

var teqLLR = func(cpu *CPU) {
	cpu.teq(cpu.llr)
}

var teqLRI = func(cpu *CPU) {
	cpu.teq(cpu.lri)
}

var teqLRR = func(cpu *CPU) {
	cpu.teq(cpu.lrr)
}

var teqARI = func(cpu *CPU) {
	cpu.teq(cpu.ari)
}

var teqARR = func(cpu *CPU) {
	cpu.teq(cpu.arr)
}

var teqRRI = func(cpu *CPU) {
	cpu.teq(cpu.rri)
}

var teqRRR = func(cpu *CPU) {
	cpu.teq(cpu.rrr)
}

var teqIMM = func(cpu *CPU) {
	cpu.teq(cpu.imm)
}

// Test (TST)
func (cpu *CPU) tst(addressingMode arthAddrMode) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, _ := parseDataInstr(cpu.currentInstruction)
	firstOp := cpu.readReg(firstOpReg)
	secondOp, carryOut := addressingMode()
	result := firstOp & secondOp
	cpu.setReg(destReg, result)

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

var tstLLI = func(cpu *CPU) {
	cpu.tst(cpu.lli)
}

var tstLLR = func(cpu *CPU) {
	cpu.tst(cpu.llr)
}

var tstLRI = func(cpu *CPU) {
	cpu.tst(cpu.lri)
}

var tstLRR = func(cpu *CPU) {
	cpu.tst(cpu.lrr)
}

var tstARI = func(cpu *CPU) {
	cpu.tst(cpu.ari)
}

var tstARR = func(cpu *CPU) {
	cpu.tst(cpu.arr)
}

var tstRRI = func(cpu *CPU) {
	cpu.tst(cpu.rri)
}

var tstRRR = func(cpu *CPU) {
	cpu.tst(cpu.rrr)
}

var tstIMM = func(cpu *CPU) {
	cpu.tst(cpu.imm)
}

func logicalShiftLeft(value *uint32, amount int, currentCarry bool) bool {

	if amount == 0 {
		return currentCarry
	}

	if amount < 32 {
		carryOut := bits.GetBit(*value, 32-amount)
		*value <<= amount
		return carryOut
	}

	if amount == 32 {
		carryOut := bits.GetBit(*value, 0)
		*value = 0
		return carryOut
	}

	*value = 0
	return false

}

func arthShiftRight(value *uint32, amount int, currentCarry bool) bool {
	if amount == 0 {
		return currentCarry
	}

	if amount < 32 {
		carryOut := bits.GetBit(*value, amount-1)
		bits.ShiftRightSigned(value, amount)
		return carryOut
	}

	if !bits.GetBit(*value, 31) {
		*value = 0
		return false
	}

	*value = 0xFFFFFFFF
	return true
}

func logicalShiftRight(value *uint32, amount int, currentCarry bool) bool {
	if amount == 0 {
		return currentCarry
	}

	if amount < 32 {
		carryOut := bits.GetBit(*value, amount-1)
		*value >>= amount
		return carryOut
	}

	if amount == 32 {
		carryOut := bits.GetBit(*value, 31)
		*value = 0
		return carryOut
	}

	*value = 0
	return false

}

func rotateRight(value *uint32, amount int, currentCarry bool) bool {
	if amount == 0 {
		return currentCarry
	}
	amount &= 0x1f
	if amount == 0 {
		return bits.GetBit(*value, 31)
	}

	carryOut := bits.GetBit(*value, amount-1)
	dup := *value
	dup <<= 31 - amount
	*value >>= amount
	*value |= dup
	return carryOut
}

func rotateRightExtend(value *uint32, currentCarry bool) bool {
	carryOut := bits.GetBit(*value, 0)
	*value >>= 1
	bits.SetBit(value, 31, currentCarry)
	return carryOut
}
