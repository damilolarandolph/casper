// THIS CODE WAS GENERATED BY A VERY EXHAUSTED DEVELOPER
// DO NOT EDIT !

package cpu

import (
	"github.com/damilolarandolph/casper/bits"
)

type shiftType uint8

const (
	lsl = shiftType(iota)
	lsr
	asr
	ror
	rrx
)

func lli(cpu ArmCPU) (uint32, bool) {
	instruction := cpu.currentInstruction()
	shiftAmount := int(bits.GetBits(instruction, 11, 7)) & 0xff
	// Register to be shifted
	shiftReg := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(shiftReg)
	carryOut := logicalShiftLeft(&operand, shiftAmount, cpu.isFlag(carry))

	return operand, carryOut
}

func llr(cpu ArmCPU) (uint32, bool) {
	instruction := cpu.currentInstruction()
	// Reg holding the amount of the shift
	shiftAmountReg := reg(bits.GetBits(instruction, 11, 8))
	shiftAmount := int(cpu.readReg(shiftAmountReg)) & 0xff

	shiftReg := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(shiftReg)
	carryOut := logicalShiftLeft(&operand, shiftAmount, cpu.isFlag(carry))

	return operand, carryOut
}

func lri(cpu ArmCPU) (uint32, bool) {
	instruction := cpu.currentInstruction()
	shiftAmount := int(bits.GetBits(instruction, 11, 7)) & 0xff
	if shiftAmount == 0 {
		shiftAmount = 32
	}
	register := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(register)

	carryOut := logicalShiftRight(&operand, shiftAmount, cpu.isFlag(carry))
	return operand, carryOut
}

func lrr(cpu ArmCPU) (uint32, bool) {
	instruction := cpu.currentInstruction()
	register := reg(bits.GetBits(instruction, 11, 8))
	shiftAmount := int(cpu.readReg(register)) & 0xff

	rm := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(rm)
	carryOut := logicalShiftRight(&operand, shiftAmount, cpu.isFlag(carry))
	return operand, carryOut
}

func ari(cpu ArmCPU) (uint32, bool) {
	instruction := cpu.currentInstruction()
	shiftAmount := int(bits.GetBits(instruction, 11, 7)) & 0xff
	if shiftAmount == 0 {
		shiftAmount = 32
	}
	register := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(register)

	carryOut := arthShiftRight(&operand, shiftAmount, cpu.isFlag(carry))
	return operand, carryOut
}

func arr(cpu ArmCPU) (uint32, bool) {
	instruction := cpu.currentInstruction()
	register := reg(bits.GetBits(instruction, 11, 8))
	shiftAmount := int(cpu.readReg(register)) & 0xff

	rm := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(rm)
	carryOut := arthShiftRight(&operand, shiftAmount, cpu.isFlag(carry))
	return operand, carryOut
}

func rri(cpu ArmCPU) (uint32, bool) {

	instruction := cpu.currentInstruction()
	shiftAmount := int(bits.GetBits(instruction, 11, 7)) & 0xff

	register := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(register)
	if shiftAmount == 0 {
		carryOut := rotateRightExtend(&operand, cpu.isFlag(carry))
		return operand, carryOut
	}
	carryOut := arthShiftRight(&operand, shiftAmount, cpu.isFlag(carry))
	return operand, carryOut
}

func rrr(cpu ArmCPU) (uint32, bool) {
	instruction := cpu.currentInstruction()
	register := reg(bits.GetBits(instruction, 11, 8))
	shiftAmount := int(cpu.readReg(register)) & 0xff

	rm := reg(bits.GetBits(instruction, 3, 0))
	operand := cpu.readReg(rm)
	carryOut := rotateRight(&operand, shiftAmount, cpu.isFlag(carry))
	return operand, carryOut
}

func imm(cpu ArmCPU) (uint32, bool) {
	instruction := cpu.currentInstruction()
	operand := bits.GetBits(instruction, 7, 0)
	rotate := int(bits.GetBits(instruction, 11, 8))
	carryOut := rotateRight(&operand, rotate*2, cpu.isFlag(carry))
	return operand, carryOut

}

type arthAddrMode func(cpu ArmCPU) (uint32, bool)

func isNegative(val uint32) bool {
	return bits.GetBit(val, 31)
}

func didOverflow(val1 uint32, val2 uint32) bool {
	return val2 > (0xffffffff - val1)
}

func didUnderflow(val1 uint32, val2 uint32) bool {
	return val2 > val1
}

func didSignOverflow(val1 uint32, val2 uint32) bool {
	signedVal1 := int32(val1)
	signedVal2 := int32(val2)
	result := int32(val1) + int32(val2)

	if signedVal1 < 0 && signedVal2 < 0 {
		return result >= 0
	} else if signedVal1 > 0 && signedVal2 > 0 {
		return result <= 0
	}

	return false

}

func parseDataInstr(instruction uint32) (reg, reg, bool) {
	setConditions := bits.GetBit(instruction, 20)

	destinationReg := reg(bits.GetBits(instruction, 15, 12))

	firstOpReg := reg(bits.GetBits(instruction, 19, 16))

	return firstOpReg, destinationReg, setConditions
}

// ADD Instructions

func add(addressingMode arthAddrMode, cpu ArmCPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destinationReg, setConditions := parseDataInstr(cpu.currentInstruction())
	secondOp, _ := addressingMode(cpu)
	firstOp := cpu.readReg(firstOpReg)
	result := firstOp + secondOp
	cpu.setReg(destinationReg, result)

	if !setConditions {
		return
	}

	if destinationReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(carry, didOverflow(firstOp, secondOp))
	cpu.setFlag(overflow, didSignOverflow(firstOp, secondOp))
	cpu.setFlag(zero, result == 0)
}

func addC(addressingMode arthAddrMode, cpu ArmCPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destinationReg, setConditions := parseDataInstr(cpu.currentInstruction())
	secondOp, _ := addressingMode(cpu)
	firstOp := cpu.readReg(firstOpReg)
	if cpu.isFlag(carry) {
		secondOp++
	}
	result := firstOp + secondOp
	cpu.setReg(destinationReg, result)

	if !setConditions {
		return
	}

	if destinationReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(carry, didOverflow(firstOp, secondOp))
	cpu.setFlag(overflow, didSignOverflow(firstOp, secondOp))
	cpu.setFlag(zero, result == 0)
}

// AND Instructions
func and(addressingMode arthAddrMode, cpu ArmCPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction())
	firstOp := cpu.readReg(firstOpReg)
	secondOp, carryOut := addressingMode(cpu)
	result := firstOp & secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}
	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}
	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)
}

// BIC Instruction

func bic(addressingMode arthAddrMode, cpu ArmCPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction())
	firstOp := cpu.readReg(firstOpReg)
	secondOp, carryOut := addressingMode(cpu)
	result := firstOp & ^secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

// Compare Negative (CMN)

func cmn(addressingMode arthAddrMode, cpu ArmCPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, _, _ := parseDataInstr(cpu.currentInstruction())
	firstOp := cpu.readReg(firstOpReg)
	secondOp, _ := addressingMode(cpu)
	result := firstOp + secondOp

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, didOverflow(firstOp, secondOp))
	cpu.setFlag(overflow, didSignOverflow(firstOp, secondOp))

}

// Compare (CMP)

func cmp(addressingMode arthAddrMode, cpu ArmCPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, _, _ := parseDataInstr(cpu.currentInstruction())
	firstOp := cpu.readReg(firstOpReg)
	secondOp, _ := addressingMode(cpu)
	result := firstOp - secondOp

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, !didUnderflow(firstOp, secondOp))
	cpu.setFlag(overflow, didSignOverflow(firstOp, ^secondOp))
}

// Exclusive Or (EOR)
func eor(addressingMode arthAddrMode, cpu ArmCPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction())
	firstOp := cpu.readReg(firstOpReg)
	secondOp, carryOut := addressingMode(cpu)
	result := firstOp ^ secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

// Move (MOV)
func mov(addressingMode arthAddrMode, cpu ArmCPU) {
	if !testCondition(cpu) {
		return
	}
	_, destReg, setConditions := parseDataInstr(cpu.currentInstruction())
	secondOp, carryOut := addressingMode(cpu)
	result := secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

// Move Negative (MVN)
func mvn(addressingMode arthAddrMode, cpu ArmCPU) {
	if !testCondition(cpu) {
		return
	}
	_, destReg, setConditions := parseDataInstr(cpu.currentInstruction())
	secondOp, carryOut := addressingMode(cpu)
	result := ^secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

// Logical OR (ORR)
func orr(addressingMode arthAddrMode, cpu ArmCPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction())
	firstOp := cpu.readReg(firstOpReg)
	secondOp, carryOut := addressingMode(cpu)
	result := firstOp | secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

// Reverse Subtract (RSB)
func rsb(addressingMode arthAddrMode, cpu ArmCPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction())
	firstOp := cpu.readReg(firstOpReg)
	secondOp, _ := addressingMode(cpu)
	result := secondOp - firstOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, !didUnderflow(secondOp, firstOp))
	cpu.setFlag(overflow, didOverflow(secondOp, ^firstOp))

}

// Reverse Subtract with Carry (RSC)
func rsc(addressingMode arthAddrMode, cpu ArmCPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction())
	firstOp := cpu.readReg(firstOpReg)
	if !cpu.isFlag(carry) {
		firstOp++
	}
	secondOp, _ := addressingMode(cpu)
	result := secondOp - firstOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, !didUnderflow(secondOp, firstOp))
	cpu.setFlag(overflow, didOverflow(secondOp, ^firstOp))

}

// Subtract with Carry (SBC)
func sbc(addressingMode arthAddrMode, cpu ArmCPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction())
	firstOp := cpu.readReg(firstOpReg)
	secondOp, _ := addressingMode(cpu)
	if !cpu.isFlag(carry) {
		secondOp++
	}
	result := firstOp - secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, !didUnderflow(firstOp, secondOp))
	cpu.setFlag(overflow, didOverflow(firstOp, ^secondOp))

}

// Subtract (SUB)
func sub(addressingMode arthAddrMode, cpu ArmCPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, setConditions := parseDataInstr(cpu.currentInstruction())
	firstOp := cpu.readReg(firstOpReg)
	secondOp, _ := addressingMode(cpu)
	result := firstOp - secondOp
	cpu.setReg(destReg, result)

	if !setConditions {
		return
	}

	if destReg == rPc {
		cpu.setCpsr(cpu.readSpsr())
		return
	}

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, !didUnderflow(firstOp, secondOp))
	cpu.setFlag(overflow, didOverflow(firstOp, ^secondOp))

}

// Test Equivalence (TEQ)
func teq(addressingMode arthAddrMode, cpu ArmCPU) {
	if !testCondition(cpu) {
		return
	}
	firstOpReg, destReg, _ := parseDataInstr(cpu.currentInstruction())
	firstOp := cpu.readReg(firstOpReg)
	secondOp, carryOut := addressingMode(cpu)
	result := firstOp ^ secondOp
	cpu.setReg(destReg, result)

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

// Test (TST)
func tst(addressingMode arthAddrMode, cpu ArmCPU) {
	if !testCondition(cpu) {
		return
	}

	firstOpReg, destReg, _ := parseDataInstr(cpu.currentInstruction())
	firstOp := cpu.readReg(firstOpReg)
	secondOp, carryOut := addressingMode(cpu)
	result := firstOp & secondOp
	cpu.setReg(destReg, result)

	cpu.setFlag(negative, isNegative(result))
	cpu.setFlag(zero, result == 0)
	cpu.setFlag(carry, carryOut)

}

func logicalShiftLeft(value *uint32, amount int, currentCarry bool) bool {

	if amount == 0 {
		return currentCarry
	}

	if amount < 32 {
		carryOut := bits.GetBit(*value, 32-amount)
		*value <<= amount
		return carryOut
	}

	if amount == 32 {
		carryOut := bits.GetBit(*value, 0)
		*value = 0
		return carryOut
	}

	*value = 0
	return false

}

func arthShiftRight(value *uint32, amount int, currentCarry bool) bool {
	if amount == 0 {
		return currentCarry
	}

	if amount < 32 {
		carryOut := bits.GetBit(*value, amount-1)
		bits.ShiftRightSigned(value, amount)
		return carryOut
	}

	if !bits.GetBit(*value, 31) {
		*value = 0
		return false
	}

	*value = 0xFFFFFFFF
	return true
}

func logicalShiftRight(value *uint32, amount int, currentCarry bool) bool {
	if amount == 0 {
		return currentCarry
	}

	if amount < 32 {
		carryOut := bits.GetBit(*value, amount-1)
		*value >>= amount
		return carryOut
	}

	if amount == 32 {
		carryOut := bits.GetBit(*value, 31)
		*value = 0
		return carryOut
	}

	*value = 0
	return false

}

func rotateRight(value *uint32, amount int, currentCarry bool) bool {
	amount &= 0xff
	if amount == 0 {
		return currentCarry
	}
	amount &= 0x1f
	if amount == 0 {
		return bits.GetBit(*value, 31)
	}

	carryOut := bits.GetBit(*value, amount-1)
	dup := *value
	dup <<= 31 - amount
	*value >>= amount
	*value |= dup
	return carryOut
}

func rotateRightExtend(value *uint32, currentCarry bool) bool {
	carryOut := bits.GetBit(*value, 0)
	*value >>= 1
	bits.SetBit(value, 31, currentCarry)
	return carryOut
}
